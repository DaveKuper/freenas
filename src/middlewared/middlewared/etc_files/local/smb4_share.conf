#
# SMB.CONF(5)		The configuration file for the Samba suite 
# $FreeBSD$
#
<%
        def get_db_config():
            db = {}
            db['truenas_conf'] = {"is_truenas_ha": False, "failover_status": "DEFAULT"}
            if not middleware.call_sync('notifier.is_freenas') and middleware.call_sync('notifier.failover_licensed'):
                db['truenas_conf']['is_truenas_ha'] = True
                db['truenas_conf']['failover_status'] = middleware.call_sync('notifier.failover_status')

            db['cifs'] = middleware.call_sync('datastore.query', 'services.cifs', None, {'get': True})
            db['shares'] = middleware.call_sync('datastore.query', 'sharing.cifs_share')

            return db

        def order_vfs_objects(vfs_objects):
            vfs_objects_special = ('catia', 'zfs_space', 'zfsacl', 'fruit', 'streams_xattr', 'recycle', 'aio_pthread')
            vfs_objects_ordered = []

            if 'fruit' in vfs_objects:
                if 'streams_xattr' not in vfs_objects:
                    vfs_objects.append('streams_xattr')

            for obj in vfs_objects:
                if obj not in vfs_objects_special:
                    vfs_objects_ordered.append(obj)

            for obj in vfs_objects_special:
                if obj in vfs_objects:
                    vfs_objects_ordered.append(obj)

            return vfs_objects_ordered


        def parse_db_config(db):
            pc = {}
            for share in db['shares']:
                pc[share["cifs_name"]] = {}
                pc[share["cifs_name"]].update({"path": f'"{share["cifs_path"]}"'})

                if share['cifs_comment']:
                    pc[share["cifs_name"]].update({"comment": share['cifs_comment']})
                if not share['cifs_ro']:
                    pc[share["cifs_name"]].update({"read only": "no"})
                if not share['cifs_browsable']:
                    pc[share["cifs_name"]].update({"bowseable": "no"})
                if share['cifs_guestok']:
                    pc[share["cifs_name"]].update({"guest ok": "yes"})
                if share['cifs_guestonly']:
                    pc[share["cifs_name"]].update({"guest only": "yes"})
                if share['cifs_showhiddenfiles']:
                    pc[share["cifs_name"]].update({"hide dot files": "no"})
                if share['cifs_abe']:
                    pc[share["cifs_name"]].update({"access based share enumeration": "yes"})
                if share['cifs_hostsallow']:
                    pc[share["cifs_name"]].update({"hosts allow": share['cifs_hostsallow']})
                if share['cifs_hostsdeny']:
                    pc[share["cifs_name"]].update({"hosts deny": share['cifs_hostsdeny']})

                ordered_vfs_objects = order_vfs_objects(share['cifs_vfsobjects'])
                pc[share["cifs_name"]].update({"vfs objects": ordered_vfs_objects})

                if share['cifs_recyclebin']:
                    pc[share["cifs_name"]].update({"recycle:repository": ".recycle/%U"})
                    pc[share["cifs_name"]].update({"recycle:keeptree": "yes"})
                    pc[share["cifs_name"]].update({"recycle:keepversions": "yes"})
                    pc[share["cifs_name"]].update({"recycle:touch": "yes"})
                    pc[share["cifs_name"]].update({"recycle:directory_mode": "0777"})
                    pc[share["cifs_name"]].update({"recycle:subdir_mode": "0700"})

                pc[share["cifs_name"]].update({"nfs4:mode": "special"})
                pc[share["cifs_name"]].update({"nfs4:chown": "true"})
                pc[share["cifs_name"]].update({"nfs4:acedup": "merge"})
                pc[share["cifs_name"]].update({"nfs4:acedup": "merge"})
                pc[share["cifs_name"]].update({"zfsacl:acesort": "dontcare"})
                pc[share["cifs_name"]].update({"veto files": "/.windows/.mac/"})

                for param in share['cifs_auxsmbconf'].splitlines():
                    param_kv = [kv.lstrip().rstrip() for kv in param.split("=")]
                    pc[share["cifs_name"]].update({param_kv[0]: param_kv[1]})

            return pc 
                
        db = get_db_config()
        parsed_conf = {}
        parsed_conf = parse_db_config(db)
         

%>

% if db['truenas_conf']['failover_status'] is not "BACKUP":
% for share_name, share in parsed_conf.items():
[${share_name}]
    % for param, value in share.items():
      % if type(value) == list:
        ${param} = ${' '.join(value)}
      % else:
        ${param} = ${value}
      % endif
    % endfor
                    
% endfor
% endif
